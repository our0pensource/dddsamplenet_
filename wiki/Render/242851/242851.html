<div class="wikidoc"><h1>Versions and modes of DDDSample.Net</h1>
DDDSample.Net currently comes in four different versions. Each versions presents a lightly different application of Domain Driven Design principles and patterns.<br />
<h2>Classic / Vanilla</h2>
This is historically the first version. It is a direct port of Java <a href="http://dddsample.sourceforge.net">DDDSample</a>. I tried to keep as close to the original design, as possible. The only differences are described in these two articles: <a href="http://simon-says-architecture.com/2009/10/10/value-objects">value objects</a>, <a href="http://simon-says-architecture.com/2009/10/28/entities">entities</a>.<br /><br />Classic version comes in two different operation modes: <b>synchronous</b> and <b>asynchronous</b>. This qualification is based on the way Domain Events are processed. In synchronous (default) mode, when a domain event is published, it is <b>immediately, synchronously</b> (on the same thread) processed by a handler. In asynchronous operation mode events are <b>transformed to messages</b> and published using <a href="http://www.nservicebus.com">NServiceBus</a>. Messages are then processed by NServiceBus runtime via dedicated message handlers which transform messages back to domain model operations.<br />
<h2>CQRS</h2>
This version implements Command and Query Responsibility Segregation principle. CQRS advocates separation (physical, logical or both) of command and query processing facilities. There are some elements of CQRS present in classic DDDSample.NET. For example, there are two distinct aggregates representing cargo from different perspectives: <span class="codeInline">Handling</span> aggregate is optimized for transaction processing while <span class="codeInline">Cargo</span> aggregate is optimized for queries. CQRS version, however, makes all these segregation concepts explicit.<br /><br />There are separate models for domain (commands) and reporting (queries). Both models have their own persistence layers (based on NHibernate). Application layer (which is a facade of the domain) invokes operations on domain objects. Side effects of these operations are published through domain events which are then transformed to NServiceBus messages. These messages are processed by reporting facility and appropriate updates are applied to reporting data structures.<br />
<h2>CQRS - LINQ to SQL</h2>
This version is a variant of previous solution in which reporting model and persistence was implemented using LINQ to SQL. The sole purpose of this version is to demonstrate inherent simplicity of reporting model. As said Udi Dahan, CQRS reporting side is so simple, that it is literally a <b>persistent view model.</b><br />
<h2>CQRS - Event Sourcing</h2>
This version shows a slightly different approach to CQRS. It follows Greg Young ideas (very well documented by Mark Nijhof) of CQRS combined with Event Sourcing. The command facility uses Event Sourcing-based persistence mechanisms. Domain objects are represented by a series of events which have business meaning (like <span class="codeInline">DestinationChangedEvent</span>) rather than snapshots of last state.<br /><br />In addition to these changes, also UI -- domain communication has been changed. It uses commands to represent business operations. For demonstration purposes commands are not directly executed on web tier but are send using NServiceBus and dispatched to appropriate handlers.</div><div class="ClearBoth"></div>